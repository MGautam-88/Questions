//---------------------------------------------------RECURSION O(2^n)--------------------------------------------------------
int solve(vector<vector<int>> &p,int n,int c,int i){
    if(i==n-1){
        return max({p[i][(c+1)%3],p[i][(c+2)%3]});
    }

    return max(solve(p,n,(c+1)%3,i+1)+p[i][(c+1)%3] , solve(p,n,(c+2)%3,i+1)+p[i][(c+2)%3]);
}

int ninjaTraining(int n, vector<vector<int>> &p){
    return max({solve(p,n,0,0),solve(p,n,1,0),solve(p,n,2,0)});
}

//-------------------------------------------------------------------------------------------------------------------------------

//--------------------------------------------------------DP O(3*n)----------------------------------------------------------------

int ninjaTraining(int n, vector<vector<int>> &p){
    if(n == 1)return max({p[0][0], p[0][1], p[0][2]});
    
    vector<vector<int>> dp(n, vector<int>(3, 0));

    for(int c = 0; c < 3; c++){
        dp[n-1][c] = max(p[n-1][(c+1)%3], p[n-1][(c+2)%3]);
    }

    for(int i = n-2; i >= 1; i--){
        for(int c = 0; c < 3; c++){
            dp[i][c] = max(
                p[i][(c+1)%3] + dp[i+1][(c+1)%3],
                p[i][(c+2)%3] + dp[i+1][(c+2)%3]
            );
        }
    }

    int ans = 0;
    for(int c = 0; c < 3; c++){
        ans = max(ans, p[0][c] + dp[1][c]);
    }

    return ans;
}

//------------------------------------------------------------------------------------------------------------------------------------

//
